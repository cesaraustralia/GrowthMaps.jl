<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · GrowthMaps.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GrowthMaps.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Load-some-required-packages"><span>Load some required packages</span></a></li><li><a class="tocitem" href="#Define-model-components"><span>Define model components</span></a></li><li><a class="tocitem" href="#Load-spatial-data"><span>Load spatial data</span></a></li><li><a class="tocitem" href="#Run-a-model-over-the-spatial-data"><span>Run a model over the spatial data</span></a></li><li><a class="tocitem" href="#Compare-with-observation-data"><span>Compare with observation data</span></a></li><li><a class="tocitem" href="#Parametrising-models-using-interactive-maps"><span>Parametrising models using interactive maps</span></a></li><li><a class="tocitem" href="#Use-the-SMAP-dataset"><span>Use the SMAP dataset</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cesaraustralia/GrowthMaps.jl/blob/master/docs/src/example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GrowthMaps.jl-example"><a class="docs-heading-anchor" href="#GrowthMaps.jl-example">GrowthMaps.jl example</a><a id="GrowthMaps.jl-example-1"></a><a class="docs-heading-anchor-permalink" href="#GrowthMaps.jl-example" title="Permalink"></a></h1><p><em>Rafael Schouten and James Maino</em>  </p><p>In this example we will calculate the expected population growth rates of Spotted Wing Drosophila (SWD) <em>D. suzukii</em>, for each month of the year on a 9km grid accross North America.</p><p>We&#39;ll experiment with running the model with a number of different datasets. GrowthMaps.jl, via GeoData.jl faciliates using a wide range of input sources. First we will use aggregated data in tiff files, then aggregate them to in-memory files to run the inferface. Finally if you can download it, we&#39;ll use the (huge) SMAP dataset, which is in a custom HDF5 format.</p><p>If you are using this as a .jmd file, it&#39;s best in to use atom with the &quot;uber-juno&quot; and &quot;language-weave&quot; plugins.</p><h2 id="Load-some-required-packages"><a class="docs-heading-anchor" href="#Load-some-required-packages">Load some required packages</a><a id="Load-some-required-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Load-some-required-packages" title="Permalink"></a></h2><p>These packages take care of loading and plotting data, and handling sci units and dates.</p><pre><code class="language-julia">
using GrowthMaps, Plots, Unitful, UnitfulRecipes, Dates
using GeoData, ArchGDAL, NCDatasets
using CSV, DataFrames
using Unitful: °C, K, cal, mol
basedir = joinpath(dirname(@__FILE__), &quot;../&quot;)</code></pre><h2 id="Define-model-components"><a class="docs-heading-anchor" href="#Define-model-components">Define model components</a><a id="Define-model-components-1"></a><a class="docs-heading-anchor-permalink" href="#Define-model-components" title="Permalink"></a></h2><p>First we&#39;ll define the growth model using <code>SchoolfieldIntrinsicGrowth</code>, based on Schoolfield (1981).</p><p>When defining model components, the first parameter is a <code>:symbol</code> for the required raster layer in the source data.</p><pre><code class="language-julia">
p = 3e-01
ΔH_A = 3e4cal/mol
ΔH_L = -1e5cal/mol
ΔH_H = 3e5cal/mol
Thalf_L = 2e2K
Thalf_H = 3e2K
T_ref = K(25.0°C)
growthmodel = SchoolfieldIntrinsicGrowth(p, ΔH_A, ΔH_L, Thalf_L, ΔH_H, Thalf_H, T_ref)
growth = Layer(:surface_temp, K, growthmodel)</code></pre><p>If these are only estimated parameters, We can fit the model to a a dataset of growth rate and temperature. First extract our independent and dependent variables from the example CSV:</p><pre><code class="language-julia">
mkpath(joinpath(basedir, &quot;build&quot;))
obsdata = CSV.File(joinpath(basedir, &quot;swd_ecophys_data.csv&quot;), select=[:x_value, :y_value, :y_key]) |&gt; DataFrame
obsdata = filter(d -&gt; d.y_key == &quot;r_m&quot;, obsdata) |&gt; dropmissing</code></pre><p>Then extract the required data colummns, and convert temperature values from unitless Celcius to explit Kelvins, using Unitful.jl:</p><pre><code class="language-julia">
obsrate = obsdata.y_value
obstemp = obsdata.x_value * °C .|&gt; K
obs = collect(zip(obstemp, obsrate))</code></pre><p>Now we can fit the model. The <code>fitrate</code> function provides an easy way to fit the models in GrowthMaps or your own custom <code>RateModel</code>s, using the LsqFit.jl package:</p><pre><code class="language-julia">
fittedgrowth = fit(growth, obs)</code></pre><p>Now plot the fit against the data:</p><pre><code class="language-julia">
temprange = (270.0:0.1:310.0)K
p = plot(x -&gt; GrowthMaps.rate(fittedgrowth, x), temprange; label=&quot;fitted&quot;)
scatter!(p, obs; label=&quot;observed &quot;)</code></pre><p><img src="../figures/example_6_1.png" alt/></p><p>We can also try tweaking the fitting the model manually in a user interface. Model components are immutable (for performance reasons), so we wrap the model in a mutable wraper so we can use the results. We parametrise the model over the same temperature range that we are plotting, using the :surface_temp key that the model requires:</p><pre><code class="language-julia">
wrapper = ModelWrapper(fittedgrowth)
tempdata=(surface_temp=temprange,)
manualfit!(wrapper, tempdata; obs=obs)</code></pre><p>If you are happy with the result, you we can update extract the manual fit to use to generate our growth rate maps:</p><pre><code class="language-julia">
fittedgrowth = wrapper.model</code></pre><p>Note that <code>manualfit!</code> will also work for a tuple of model components that use the same source data, like <code>(growth, heatstress, coldstress)</code>.</p><h2 id="Load-spatial-data"><a class="docs-heading-anchor" href="#Load-spatial-data">Load spatial data</a><a id="Load-spatial-data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-spatial-data" title="Permalink"></a></h2><p>Later we can use real SMAP datasets using GeoData.jl SMAPseries loader. But downloading the dataset takes too long for an example. Instead we will download and unzip some lower resolution monthly data to use in the model:</p><pre><code class="language-julia">
dataurl = &quot;https://media.githubusercontent.com/media/cesaraustralia/GrowthMaps.jl/data/SMAP_aggregated27km.zip&quot;
zipfilepath = joinpath(basedir, &quot;SMAP_aggregated27km.zip&quot;)
unzippedfolder = joinpath(basedir, &quot;SMAP_aggregated27km&quot;)
isfile(zipfilepath) || download(dataurl, zipfilepath)
run(`unzip -o $zipfilepath -d $basedir`);

# Get the paths for to all the wilting and surface temp files
filenames = readdir(unzippedfolder)
wilting_filenames = filter(fn -&gt; occursin(r&quot;land_fraction_wilting&quot;, fn), filenames)
surface_temp_filenames = filter(fn -&gt; occursin(r&quot;surface_temp&quot;, fn), filenames)
wilting_paths = joinpath.(Ref(unzippedfolder), wilting_filenames)
surface_temp_paths = map(p -&gt; joinpath(unzippedfolder, p), surface_temp_filenames)

# Get the dates covered in the data from the `surface_temp` files list using regex
df = DateFormat(&quot;yyyymmddTHHMMSS&quot;);
dates = DateTime.(replace.(surface_temp_paths, Ref(r&quot;.*_(\d+T\d+).tif&quot; =&gt; s&quot;\1&quot;)), Ref(df))</code></pre><p>We know the <code>land_fraction_wilting</code> files are for the same dates.</p><p>Now we have the files and date seies, we can put together a series of GeoData.jl stacks to load lazily from disk while running <code>mapgrowth</code>.</p><p>The beauty of this approach is that we can use a lot of different source file types and folder configurations without converting them or running out of RAM.</p><pre><code class="language-julia">
function makestack(i)
    GDALstack((land_fraction_wilting=wilting_paths[i],
               surface_temp=surface_temp_paths[i]);
        window=(Band(1),), # lazy view applied when the file is loaded.
        childkwargs=(usercrs=EPSG(4326),), # lets us use lat/lon without knowing the underlying projection
    )
end
stacks = [makestack(i) for i in 1:length(surface_temp_paths)]
timedim = Ti(dates; mode=Sampled(span=Regular(Hour(3))))
tiffseries = GeoSeries(stacks, (timedim,))</code></pre><p>We can plot a layer from a file at some date in the series:</p><pre><code class="language-julia">
tiffseries[Ti(Near(DateTime(2016, 2)))][:surface_temp] |&gt; plot</code></pre><p><img src="../figures/example_11_1.png" alt/></p><p>Set the time period to a month, and set the length of the subsample period to the available times over one day:</p><h2 id="Run-a-model-over-the-spatial-data"><a class="docs-heading-anchor" href="#Run-a-model-over-the-spatial-data">Run a model over the spatial data</a><a id="Run-a-model-over-the-spatial-data-1"></a><a class="docs-heading-anchor-permalink" href="#Run-a-model-over-the-spatial-data" title="Permalink"></a></h2><p>Define a timespan range to run the model over:</p><pre><code class="language-julia">
tspan=DateTime(2016, 1):Month(1):DateTime(2016, 12)</code></pre><pre><code class="language-none">Dates.DateTime(&quot;2016-01-01T00:00:00&quot;):Dates.Month(1):Dates.DateTime(&quot;2016-1
2-01T00:00:00&quot;)</code></pre><p>Then to start, we&#39;ll run a simple model that only calculates growth rate.</p><pre><code class="language-julia">
output = mapgrowth(fittedgrowth;
  series=tiffseries,
  tspan=tspan,
)</code></pre><p>Then plot the results:</p><pre><code class="language-julia">
output[Ti(1)] |&gt; plot</code></pre><p><img src="../figures/example_14_1.png" alt/></p><p>It doesn&#39;t really capture realistic population growth: there are no growth rates below zero. We need to add some stress models. Stress models model processes that produce negative deathrates in the population, as oposed to rate models, where the minimum growth rate is zero.</p><p>Stress models have a threshold in K and mortality rate per degree K. <code>LowerStress</code> models stress below the given threshold, while <code>UpperStress</code> models stress induced above a threshold.</p><p>We will define stress models for cold, heat and wilt stress. As SWD live on and around plants, we use the proportion of plants wilting as an indicater of stress induced by lack of moisture.</p><pre><code class="language-julia">
coldthresh = 7.0°C |&gt; K  # Enriquez2017
coldmort = -log(1.00) * K^-1
coldstress = Layer(:surface_temp, K, ColdStress(coldthresh, coldmort))

heatthresh = 30.0°C |&gt; K # Kimura2004
heatmort = -log(1.15) * K^-1
heatstress = Layer(:surface_temp, K, HeatStress(heatthresh, heatmort))

wiltthresh = 0.5 # default?
wiltmort = -log(1.1);
wiltstress = Layer(:land_fraction_wilting, WiltStress(wiltthresh, wiltmort));</code></pre><p>To build a more complex model, we can chain components together in a tuple, and again, run and plot them:</p><pre><code class="language-julia">
output = mapgrowth(fittedgrowth, heatstress;
    series=tiffseries,
    tspan=tspan,
)
output[Ti(1)] |&gt; plot</code></pre><p><img src="../figures/example_16_1.png" alt/></p><p>That looks better. There are negative growth rates in hot regions. Now lets run a full model with growth and three stressors:</p><pre><code class="language-julia">
output = mapgrowth(fittedgrowth, coldstress, heatstress, wiltstress;
    series=tiffseries,
    tspan=tspan,
)
output[Ti(1)] |&gt; plot</code></pre><p><img src="../figures/example_17_1.png" alt/></p><h2 id="Compare-with-observation-data"><a class="docs-heading-anchor" href="#Compare-with-observation-data">Compare with observation data</a><a id="Compare-with-observation-data-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-with-observation-data" title="Permalink"></a></h2><p>To compare out simulation with observations data, we&#39;ll first load them from a CSV file:</p><pre><code class="language-julia">
csvurl = &quot;https://raw.githubusercontent.com/cesaraustralia/GrowthMaps.jl/data/Oersted_occurrence.csv&quot;
csvfilename = joinpath(basedir, &quot;Oersted_occurrence.csv&quot;)
isfile(csvfilename) || download(csvurl, csvfilename)</code></pre><p>Then scatter them on a map:</p><pre><code class="language-julia">
obs = CSV.File(csvfilename)
occurrence = collect(zip(obs.Longitude, obs.Latitude))
p = plot(output[Ti(1)])
scatter!(p, occurrence; markersize=2.0, markercolor=:white, markershape=:circle, label=&quot;obs&quot;)</code></pre><p><img src="../figures/example_19_1.png" alt/></p><h2 id="Parametrising-models-using-interactive-maps"><a class="docs-heading-anchor" href="#Parametrising-models-using-interactive-maps">Parametrising models using interactive maps</a><a id="Parametrising-models-using-interactive-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Parametrising-models-using-interactive-maps" title="Permalink"></a></h2><p>If you need to adjust the model based on the distribution, this can be done live in the interface, as with the manual fit.</p><p>But parametrising maps on large datasets is processor intensive, which inhibits interactive fedback. To reduce processing, we can aggregate the spatial data to a more manageable size.</p><p>You can experiment with the <code>agg</code> size to compromise between quality and render time. Large values will look pixelated but will run fast.</p><p><code>Center()</code> simply takes the central cell. <code>Statistics.mean</code> would take the mean value.</p><pre><code class="language-julia">
agg = 8
aggseries = GeoData.aggregate(Center(), tiffseries, (Lon(agg), Lat(agg)))</code></pre><p>As the combination of models is additive, we can pre-build parts of the model we don&#39;t want to fit manually, which simplifies the interfaces and helps performance. Seeing we allready fit the growth response to empiracle data, lets just fit the stress responses to the map:</p><pre><code class="language-julia">
modelkwargs = (series=aggseries, tspan=tspan)
precomputed = mapgrowth(fittedgrowth; modelkwargs...)</code></pre><p>Then fit the other components. <code>throttle</code> will dictate how fast the interface  updates. Make it larger on a slow machine, smaller on a faster one. The <code>window</code> argument lets us select a window of the output to view, using DimensionalData.jl/GeoData.jl <code>Dimension</code>s and <code>Selector</code>s. Here we only plot the first time: but you can select any/multiple, and select them with <code>Near(DateTime(2016,2))</code> or similar.</p><pre><code class="language-julia">
wrapper = ModelWrapper(wiltstress, coldstress, heatstress)
throttle = 0.2
interface = mapfit!(wrapper, modelkwargs;
    occurrence=occurrence,
    precomputed=precomputed,
    throttle=throttle,
    markershape=:cross,
    markercolor=:lightblue,
    markeropacity=0.4,
    window=(Ti(1),),
)</code></pre><p>In atom, this will show the interface in the plot pane:</p><pre><code class="language-julia">
display(interface)</code></pre><p>To use the it in a desktop app, use Blink.jl:</p><pre><code class="language-julia">
using Blink
w = Blink.Window()
body!(w, interface)</code></pre><p>And get the updated model components from the wrapper:</p><pre><code class="language-julia">
wiltstress, coldstress, heatstress = wrapper.model</code></pre><p>Now we will put together decent population growth maps using the higher resolutions data, and a monthly tiestep:</p><pre><code class="language-julia">
output = mapgrowth(fittedgrowth, wiltstress, coldstress, heatstress;
    series=tiffseries,
    tspan=tspan,
);
plot(output[Ti(1:3:12)]; axis=false)</code></pre><p><img src="../figures/example_26_1.png" alt/></p><p>This output is ready to use for projecting growthrates, or in a dispersal simulation using Dispersal.jl. Lets save it as a NetCDF file using GeoData.jl:</p><pre><code class="language-julia">
span(output, Ti)
savepath = joinpath(basedir, &quot;growthrates.ncd&quot;)
write(savepath, NCDarray, output)</code></pre><p>We can load it again with:</p><pre><code class="language-julia">
ncarray = NCDarray(savepath)
plot(ncarray[Ti(1)])</code></pre><p><img src="../figures/example_28_1.png" alt/></p><h2 id="Use-the-SMAP-dataset"><a class="docs-heading-anchor" href="#Use-the-SMAP-dataset">Use the SMAP dataset</a><a id="Use-the-SMAP-dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Use-the-SMAP-dataset" title="Permalink"></a></h2><p>Using aggregated data loses some of the impact of the stress models, which respond to extremes, not averages. If you need to use the model for a serious application, run it on the real SMAP dataset.</p><p>Unfortunately we can&#39;t just download the data for you with a script, as you need to log in to an account to have access.</p><p>But GeoData.jl has a <code>SMAPseries()</code> constructor that will automate the whole process of loading SMAP HDF5 files from a folder once you have the data.</p><p>We can also reduce the numer of days processed to 8 each month (or whatever) using the <code>Where</code> selector from DimensionalData.jl.</p><pre><code class="language-julia">
using HDF5
# Set this to your own SMAP data folder
smappath = &quot;/home/raf/Storage/Data/SMAP/SMAP_L4_SM_gph_v4&quot;
# Choose the dayes of month to use
days = (1, 4, 8, 12, 16, 20, 23, 27) # 8 days per month
#days = 1:31 # all days
# Use the `Where` selector to choose dates in the time index by day of month
smapseries = SMAPseries(smappath)[Ti(Where(d -&gt; dayofmonth(d) in days))]</code></pre><p>Run the model:</p><pre><code class="language-julia">
@time output = mapgrowth(fittedgrowth, wiltstress, coldstress, heatstress;
    series=smapseries, tspan=tspan,
)
plot(output[Ti(1:3:12)]; axis=false)</code></pre><p>And save a netcdf:</p><pre><code class="language-julia">
write(joinpath(basedir, &quot;growthrates.ncd&quot;), NCDarray, output)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 August 2020 05:11">Monday 31 August 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
