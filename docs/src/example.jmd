---
title : GrowthMaps.jl example
author : Rafael Schouten, James Maino
---

# Growth rate calculation

In this example we will calculate the expected population growth rates of
Spotted Wing Drosophila _D. suzukii_, for each month of the year on a 9km grid
accross North America.

We'll subsample down to using just one day per month so the model runs really
fast. If you have a GPU you may want to try running more days.


## Load the required packages


```julia; results=hidden
using GrowthMaps, GeoData, Dates, Plots, Unitful, Pkg
using GeoData: Time
# Load some Unitful.jl units
using Unitful: °C, K, cal, mol
basedir = Pkg.dir("GrowthMaps")

# download some smap files?
```

Load the file series and set a window for the data that is loaded, to save
processing time:


```julia; results=hidden
series = SMAPseries(joinpath(basedir, "test"); 
                    window=(Lon<|Between(-125, -75), Lat(150:480)));

```


We can plot a layer from a file at some date in the series:


```julia; results=hidden
series[Near(Date(2016))][:surface_temp] |> plot
savefig("build/assets/surface_temp.png")
```

![Sea surface temperature](../assets/surface_temp.png)

Set the time period to a month, and set the length of the subsample period to
the available times over one day:


## Define model components

First we'll define the growth model using `IntrsinsicGrowth`, based on
Schoolfield (1981).

When defining model components, the first parameter is always the key for the
stack layer, from the list we saw earlier using `keys()`.

```julia; results=hidden
p = 3.377850e-01
ΔH_A = 3.574560e+04cal/mol
ΔH_L = -1.108990e+05cal/mol
ΔH_H = 3.276604e+05cal/mol
Thalf_L = 2.359187e+02K
Thalf_H = 2.991132e+02K
T_ref = K(25.0°C)
R = Unitful.R
growth = IntrinsicGrowth(:surface_temp, p, ΔH_A, ΔH_L, 
                         ΔH_H, Thalf_L, Thalf_H, T_ref, R)
```

Now we define stress models for cold, heat and wilt stress. As these insects
live on and around plants, we use wilting as an indicater of stress induced by
lack of moisture. These models have a threshold in K and mortality rate per
degree K. `LowerStress` models stress below the given threshold, while
`UpperStress` models stress induced above a threshold.

```julia; results=hidden
coldthresh = 7.0°C |> K  # Enriquez2017
coldmort = -log(1.00) * K^-1
heatthresh = 30.0°C |> K # Kimura2004
heatmort = -log(1.15) * K^-1
wiltthresh = 0.5 # default?
wiltmort = -log(1.1);

coldstress = LowerStress(:surface_temp, coldthresh, coldmort)
heatstress = UpperStress(:surface_temp, heatthresh, heatmort)
wiltstress = UpperStress(:land_fraction_wilting, wiltthresh, wiltmort);
```

## Combine components into a model

To build a model, we simple chain components together in a tuple:


```julia; results=hidden
model = (growth, coldstress, heatstress, wiltstress);
# Some alternative models:
# model = (wiltstress,)
# model = (growth, wiltstress)
# model = (growth, coldstress, heatstress)
```

## Use your GPU?

If you have a GPU you can use `CuArray` from
[CuArrays.jl](https://github.com/JuliaGPU/CuArrays.jl) to move processing to the
GPU for a ~10x performance improvement. Otherwise the `identity` function simply
leaves the data as-is on the CPU.


```julia; results=hidden
constructor = identity
# using CuArrays
# constructor = CuArray
```

## Run your model

```julia; results=hidden
output = mapgrowth(model, series; 
                   period=Month(1),
                   nperiods=12,
                   subperiod=Day(1), 
                   constructor=constructor);
output[Time(1)] |> plot
savefig("build/assets/growthrates.png")
```

![Growth Rates](../assets/growthrates.png)

Save the output to the `docs/build` folder (or wherever you like).

```julia; results=hidden
using JLD2
path = joinpath(basedir, "docs/build")
mkpath(path)
rates = output
@save joinpath(path, "growthrates.jld2") rates 
```

## Compare with observation data

Plot again, setting the x and y lims (do automatically in GeoData.jl?)

```julia; results=hiddeats
array = output[Time(1)]
p = plot(array; xlim=bounds(dims(array, Lon)), ylim=bounds(dims(array, Lat)))
```

Load observations from a CSV file, and scatter them on the map. The
`zip` function joins Lat and Lon columns into point tuples, which can 
be plotting using Plots.jl.

```julia; results=hiddeats
using CSV
obs = CSV.File("/home/raf/CESAR/Oersted_occurrence.csv")
scatter!(p, collect(zip(obs.Longitude, obs.Latitude)); 
         markersize=0.5, markercolor=:grey, markershape=:dtriangle, label="obs",
         xlim=bounds(dims(array, Lon)), ylim=bounds(dims(array, Lat))
         )
```
