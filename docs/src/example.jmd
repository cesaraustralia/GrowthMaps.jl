---
title : GrowthMaps.jl example
author : Rafael Schouten, James Maino
---

# Growth rate calculation

In this example we will calculate the expected population growth rates of
Spotted Wing Drosophila (SWD) _D. suzukii_, for each month of the year on a 9km grid
accross North America.

We'll subsample down to using just one day per month so the model runs really fast.


## Load some required packages

These packages take care of loading and plotting data, and handling sci units and dates.

```julia; results=hidden
using GrowthMaps, Plots, Unitful, UnitfulRecipes, Dates
using Unitful: °C, K, cal, mol
basedir = joinpath(dirname(Base.pathof(GrowthMaps)), "../docs")
```


## Define model components

First we'll define the growth model using `SchoolfieldIntrinsicGrowth`, based on
Schoolfield (1981).

When defining model components, the first parameter is a `:symbol` for the
required raster layer in the source data.

```julia; results=hidden
p = 3e-01
ΔH_A = 3e4cal/mol
ΔH_L = -1e5cal/mol
ΔH_H = 3e5cal/mol
Thalf_L = 2e2K
Thalf_H = 3e2K
T_ref = K(25.0°C)
growthmodel = SchoolfieldIntrinsicGrowth(p, ΔH_A, ΔH_L, Thalf_L, ΔH_H, Thalf_H, T_ref)
growth = Layer(:surface_temp, growthmodel)
```


If these are only estimated parameters, We can fit the model to a a dataset of growth
rate and temperature. First extract our independent and dependent variables (xs
and ys) from the example CSV:

```julia; results=hidden
using CSV, DataFrames, Tables
mkpath(joinpath(basedir, "build"))
obsdata = CSV.File(joinpath(basedir, "swd_ecophys_data.csv")) |>
       Tables.select(:x_value, :y_value, :y_key) |> DataFrame
obsdata = filter(d -> d.y_key == "r_m", obsdata) |> dropmissing
```


Then extract the required data colummns, and convert temperature values from
unitless Celcius to explit Kelvins, using Unitful.jl:

```julia; results=hidden
obsrate = obsdata.y_value
obstemp = obsdata.x_value * °C .|> K
```


Now we can fit the model. The `fitrate` function provides an easy way to fit the
models in GrowthMaps or your own custom `RateModel`s, using the LsqFit.jl
package:

```julia; results=hidden
fittedgrowth = fit(growth, obstemp, obsrate)
```


Now plot the fit against the data:

```julia; results=hidden
temprange = 270.0:0.1:310.0
p = plot(x -> GrowthMaps.rate(fittedgrowth, x), temprange; label="fitted")
scatter!(p, obstemp, obsrate; label="observed ")
```

We can also try tweaking the fitting the model manually in a user interface.
Model components are immutable (for performance reasons), so we wrap the model
in a mutable wraper so we can use the results.
We parametrise the model over the same temperature range that we are plotting,
using the :surface_temp key that the model requires:


```julia; results=hidden
wrapper = ModelWrapper(fittedgrowth)
tempdata=(surface_temp=temprange,)
manualfit!(wrapper, obstemp, obsrate, tempdata)
```


If you are happy with the result, you we can update extract the manual fit
to use to generate our growth rate maps:

```julia; results=hidden
fittedgrowth = wrapper.model
```


Note that `manualfit!` will also work for a tuple of model components
that use the same source data, like `(growth, heatstress, coldstress)`.


## Load spatial data

Now we'll load a few more packages to import spatial rasters to use with the model:

```julia; results=hidden
using ArchGDAL, NCDatasets, GeoData
using GeoData: Time
```


Later we can use real SMAP datasets using GeoData.jl SPAMseries loader.
But downloading the dataset takes too long for an example.
Instead we will download and unzip some lower ress monthly SMAP data to use in the model:

```julia; results=hidden
dataurl = "https://media.githubusercontent.com/media/cesaraustralia/GrowthMaps.jl/data/SMAP_aggregated27km.zip"
zipfilepath = joinpath(basedir, "SMAP_aggregated27km.zip")
unzippedfolder = joinpath(basedir, "SMAP_aggregated27km")
isfile(zipfilepath) || download(dataurl, zipfilepath)
run(`unzip -o $zipfilepath -d $unzippedfolder`)
```


Get the paths for to all the wilting and surface temp files using `filter`:

```julia; results=hidden
filenames = readdir(unzippedfolder);
wilting_filenames = filter(fn -> occursin(r"land_fraction_wilting", fn), filenames)
surface_temp_filenames = filter(fn -> occursin(r"surface_temp", fn), filenames)
wilting_paths = joinpath.(Ref(unzippedfolder), wilting_filenames)
surface_temp_paths = joinpath.(Ref(unzippedfolder), surface_temp_filenames)
```


Get the dates covered in the data from the `surface_temp` files list, using regex:

```julia; results=hidden
df = DateFormat("yyyymmddTHHMMSS");
dates = DateTime.(replace.(surface_temp_paths, Ref(r".*_(\d+T\d+).tif" => s"\1")), Ref(df));
```


We know the "land_fraction_wilting" files are for the same dates.

Now we have the files and date seies, we can put together
a series of GeoData.jl stacks to load from disk while generating growth maps
The beauty of this approach is that we can use a lot of different source file types and
folder configurations without converting them or running out of RAM.

```julia; results=hidden
function makestack(i)
    GDALstack((land_fraction_wilting=wilting_paths[i],
    surface_temp=surface_temp_paths[i]); window=(Band(1),))
end
stacks = [makestack(i) for i in 1:length(surface_temp_paths)]
startdate = dates[1]
enddate = dates[end] + Hour(3)
timedim = GeoData.Time(dates; grid=RegularGrid(;step=Hour(3)))
series = GeoSeries(stacks, (timedim,))
```


We can plot a layer from a file at some date in the series:

```julia; results=hidden
series[GeoData.Time(Near(DateTime(2016, 1)))][:surface_temp] |> plot

savefig(joinpath(basedir, "build/assets/surface_temp.png"))
```

![Sea surface temperature](../assets/surface_temp.png)

Set the time period to a month, and set the length of the subsample period to
the available times over one day:



## Run a model over the spatial data

First we'll run a simple model that only calculates growth rate.

And run it:

```julia; results=hidden
startdate=DateTime(2016)
period = Month(12)
nperiods = 1
subperiod = Day(1)

output = mapgrowth(fittedgrowth, series;
                   period=period,
                   nperiods=nperiods,
                   subperiod=subperiod,
                   startdate=startdate
                  );
```


Then plot the results:

```julia; results=hidden
output |> plot
```


But it doesn't really capture realistic population growth. There are no
growth rates below zero. We need to add some stress models.

Stress models model processes that produce negative deathrates in the
population, as oposed to rate models, where the minimum growth rate is zero.

Stress models have a threshold in K and mortality
rate per degree K. `LowerStress` models stress below the given threshold, while
`UpperStress` models stress induced above a threshold.

We will define stress models for cold, heat and wilt stress.
As SWD live on and around plants, we use the proportion of plants
wilting as an indicater of stress induced by lack of moisture.

```julia; results=hidden
coldthresh = 7.0°C |> K  # Enriquez2017
coldmort = -log(1.00) * K^-1
coldstress = Layer(:surface_temp, ColdStress(coldthresh, coldmort))

heatthresh = 30.0°C |> K # Kimura2004
heatmort = -log(1.15) * K^-1
heatstress = Layer(:surface_temp, HeatStress(heatthresh, heatmort))

wiltthresh = 0.5 # default?
wiltmort = -log(1.1);
wiltstress = Layer(:land_fraction_wilting, WiltStress(wiltthresh, wiltmort));
```
To build a more complex model, we can chain components together in a tuple:

```julia; results=hidden
model = fittedgrowth, heatstress;
```

And again, run and plot them:

```julia; results=hidden
output = mapgrowth(model, series;
                   period=period,
                   nperiods=nperiods,
                   subperiod=subperiod,
                   startdate=startdate
                  )
output[Time(1)] |> plot
```

That looks better. There are negative growth rates in hot regions.
Now lets define a full model with growth and three stressors:

```julia; results=hidden
model = fittedgrowth, coldstress, heatstress, wiltstress
output = mapgrowth(model, series;
                   period=period,
                   nperiods=nperiods,
                   subperiod=subperiod,
                   startdate=startdate
                  )
output[Time(1)] |> plot
savefig(joinpath(basedir, "build/assets/growthrates.png"));
```


## Compare with observation data

To compare out simulation with observations data, we'll load them
from a CSV file, and scatter them on the map:

```julia; results=hiddeats
csvurl = "https://raw.githubusercontent.com/cesaraustralia/GrowthMaps.jl/data/"
csvfilename = joinpath(basedir, "Oersted_occurrence.csv")
isfile(csvfilename) || download(joinpath(csvurl, csvfilename))
obs = CSV.File(csvfilename)
occurance = collect(zip(obs.Longitude, obs.Latitude))
p = output[GeoData.Time(1)] |> plot
scatter!(p, occurance; markersize=2.0, markercolor=:white, markershape=:circle, label="obs")
```

# Parametrising models using interactive maps

If you need to adjust the model based on the distribution, this
can be done live in the interface, as with the manual fit.

Parametrising maps on large datasets is processor intensive, which inhibits
interactive fedback. To reduce processing, we can aggregate the spatial data to
a more manageable size.

You can experiment with the `agg` size to compromise between quality and render time. Large values
will look pixelated but will run fast.
```julia; results=hidden
agg = 8
aggseries = GeoData.aggregate(series, Center(), (Lon(agg), Lat(agg)))
```

As the combination of model is additive, we can prebuild parts of the model
we don't want to fit manually, which simplifies the interfaces and helps performance.
Seeing we allready fit the growth response to empiracle data, lets just fit
the stress responses to the map:

```julia; results=hidden
modelkwargs = (; period=period, nperiods=nperiods, subperiod=subperiod, startdate=startdate)
precomputed = mapgrowth(fittedgrowth, aggseries; modelkwargs...)
```

Then fit the other components. `throttle` will dictate how fast the interface updates. Make it larger on a slow machine,
smaller on a faster one.

```julia; results=hidden
wrapper = ModelWrapper(wiltstress, coldstress, heatstress)
throttle = 0.2
mapfit!(wrapper, aggseries, modelkwargs;
        occurrance=occurance,
        precomputed=precomputed,
        throttle=throttle,
        markershape=:cross,
        markercolor=:lightblue,
        markeropacity=0.4)
```

And get the updated model components from the wrapper:

```julia; results=hidden
wiltstress, coldstress, heatstress = wrapper.model
```

Now we will put together decent population growth maps
using higher resolutions data, and a monthly timestep:

```julia; results=hidden
startdate=DateTime(2016)
period = Month(1)
nperiods = 12
subperiod = Day(1)

model = fittedgrowth, wiltstress, coldstress, heatstress
output = mapgrowth(model, series;
                   period=period,
                   nperiods=nperiods,
                   subperiod=subperiod,
                   startdate=startdate
                  );

plot(output[GeoData.Time(1:3:12)]; axis=false)
```

This is ready to use for projecting growthrates, or in a dispersal
simulation using Dispersal.jl. Lets save it as a NetCDF file:

```julia; results=hidden
savepath = joinpath(basedir, "growthrates.ncd")
write(savepath, NCDarray, output)
```

![Growth Rates](../assets/growthrates.png)

We can load it again with:

```julia; results=hidden
ncarray = NCDarray(savepath)
plot(ncarray[GeoData.Time(1:3:12)]; axis=false)
```

Now, if you need to use the model for a serious application, run it on the real
SMAP dataset. GeoData.jl has a `SMAPseries()` constructor that will automate the
whole process of loading real SMAP HDF5 files.

```julia
# using HDF5
# series = SMAPseries(folder_path)
```
